%
% Formal models and methods for program semantics, correctness and verification
%
% (c) Vadim Vinnik, 2014-18
%
% vadim.vinnik@gmail.com
%

\documentclass[landscape]{slides}
\usepackage[landscape, margin=10mm]{geometry}

\usepackage{amssymb}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\input{defs.tex}

\sloppy

\begin{document}

\author{В.Ю.\,Винник}

\title{%
Формальные модели\\%
семантики и корректности,\\%
методы спецификации\\%
и верификации программ}

\date{}

\maketitle

\begin{slide}
\begin{center}
\begin{LARGE}
Нет ничего практичнее\\%
хорошей теории
\end{LARGE}
\end{center}
\end{slide}

\begin{slide}
Зачем программированию формальные методы?
\begin{itemize}
\item Программирование есть (в том числе и) инженерная дисциплина.
\item Самолёты, мосты, электросети просчитываются математически.
\item Сложность программ не ниже сложности автомобиля или ЭВМ.
\item В программировании распространён "<ремесленный"> подход.
\item Решения основываются на здравом смысле и предпочтениях.
\item Программирование понимается как сумма практических рецептов и технических тонкостей.
\end{itemize}
\end{slide}

\begin{slide}
Зачем программированию формальные методы?
\begin{itemize}
\item Инженерная дисциплина достигает зрелости, когда обретает строгий научный фундамент.
\item Основополагающие принципы в явном виде осознаются и становятся предметом изучения.
\item Понимание этих принципов достигает степени, допускающей их выражение языком математики.
\item Практика предстаёт воплощением этих абстрактных принципов.
\item "<От живого созерцания к абстрактному мышлению и от него к практике"> (В.И.\,Ленин).
\item Хорошая теория (особенно математическая) позволяет делать полезные изобретения, недоступные при чисто ремесленном подходе.
\end{itemize}
\end{slide}

\begin{slide}
Прецедент~-- синтаксическая революция
\begin{itemize}
\item В 1950--1960-х гг. создание каждого транслятора было серьёзной проблемой.
\item Без матмодели~-- подход к каждому языку, оператору, синтаксической конструкции "<в розницу">.
\item Каждый транслятор привносил свой диалект языка.
\item Математический аппарат (кс-грамматики, БНФ, LL($k$) и др.) позволил решить весь класс проблем "<оптом">.
\item Метасистемный переход по В.Ф.\,Турчину.
\item Эталон: синтаксис новых языков должен быть таким, чтобы хорошо отображаться в БНФ.
\end{itemize}
\end{slide}

\begin{slide}
Ожидание семантической революции
\begin{itemize}
\item Средства автоматизированного анализа программ.
\item Раннее обнаружение семантических ошибок.
\item Автоматизированный синтез программ по спецификациям.
\item Строгий критерий для оценивания качества программ.
\item Эталон для оценивания качества языков.
\item Разработка более изящных языков, парадигм и технологий программирования на строгом математическом фундаменте.
\end{itemize}
\end{slide}

\begin{slide}
Связь теории и практики программирования
\begin{itemize}
\item Естественные науки изучают предмет, данный в готовом виде.
\item Инженерия создаёт новые объекты, пользуясь моделями естественных наук.
\item Математика создаёт свой предмет по ходу изучения его.
\item Математическая теория программирования не только изучает его нынешнее состояние, но и направляет его дальнейшее развитие.
\item Написать программу "<Hello World"> можно без привлечения матмоделей, а создать новый каркас (framework), язык или парадигму~-- нет.
\end{itemize}
\end{slide}

\begin{slide}
Формальные методы и обеспечение корректности программ
\begin{itemize}
\item "<Тестирование программы может весьма эффективно продемонстрировать наличие ошибок, но безнадёжно неадекватно для демонстрации их отсутствия"> (Э.\,Дейкстра).
\item Формальные методы позволяют \emph{доказывать} правильность программм математически (формальная верификация).
\item Еще лучше доказывать правильность программы до её создания~-- текст программы может из доказательства извлечь машина (формальный синтез).
\item В пределе~-- переход от написания программ к написанию спецификаций, оставив синтез программного текста машине.
\end{itemize}
\end{slide}

\begin{slide}
Формальные методы в повседневной работе?
\begin{itemize}
\item Для некоторых категорий ПО требуется формальное доказательство ПО соответствия требованиям ТЗ (ГОСТ Р 51904-2002).
\item Методы формальной верификации громоздки и неудобны для использования человеком;
\item Доказательство корректности элементарной программы длиннее самой программы;
\item Автоматизации поддаются плохо: в общем случае проблема неразрешима (слава Гёделю);
\item Формальное доказательство корректности программ проводится редко\ldots
\end{itemize}
\end{slide}

\begin{slide}
Однако\ldots Повышение культуры программирования!
\begin{itemize}
\item Человек, постигший фундаментально-математическую сторону программирования, более не сможет
"<просто ``лепить команды'', т.е. выдавать тексты, основанные на неубедительных предположениях, несостоятельность которых может выявиться после первого же противоречащего примера"> (Э.\,Дейкстра).
\item Программист, понимающий математическую суть семантики, будет мыслить о коде более чётко и строго.
\item Человек, грамотно говорящий на родном языке может не задумываться о каждом подлежащем или падеже\ldots
\item Но грамотно говорящим становится только после того, как один раз в грамматике разберётся.
\item Усвоить правило~-- значит забыть его и далее применять, не сознавая этого.
\end{itemize}
\end{slide}

\begin{slide}
Семиотика~-- общая наука о знаковых системах.

\begin{center}
\begin{tabular}{|l|l|l|}
        \hline
        Синтактика & Знак -- знак    & Как пишется         \\ \hline
        Семантика  & Знак -- объект  & Что означает        \\ \hline
        Прагматика & Знак -- субъект & Зачем употребляется \\ \hline
\end{tabular}
\end{center}

Г.\,Фреге: Знак --- смысл --- значение

Синтаксис~-- набор ключевых слов, правила составления выражений и конструкций. Зависит от конкретного языка.

Семантические знания: что такое переменная, цикл, вызов функции, класс, объект и наследование. Общие для целых классов языков.

Прагматика программных текстов: (1)~решить конкретную задачу; (2)~донести идею решения до других людей.
\end{slide}

\begin{slide}
Методологические замечания
\begin{itemize}
\item Наука \emph{не} познаёт "<Истину"> (с Большой Буквы);
\item Наука строит модели действительности;
\item Некоторые модели более адекватны, чем другие;
\item Всякая модель имеет свою область применимости.
\item Всякая модель отбрасывает некоторые стороны предмета.
\item "<Карта не есть местность"> (А.\,Кожибский).
\end{itemize}
Поэтому \emph{все} теории и модели программирования страдают изъянами и
не охватывают всего явления.
\end{slide}

\begin{slide}
    \begin{center}
        \begin{LARGE}
            Теоретизирование~--\\это отыскивание сомнительных причин\\для обоснования того,\\во что и так веришь\\интуитивно.
        \end{LARGE}
    \end{center}
\end{slide}

\setlength{\unitlength}{6mm}
\begin{slide}
Программа как чёрный ящик принимает исходные данные и выдаёт результаты

\begin{center}
\begin{picture}(8,10)
\newcommand{\figBox}[1]{\makebox(8,2)[c]{\shortstack[c]{#1}}}
\newcommand{\figArrow}{\vector(0,-1){2}}
\put(0,8){\figBox{Исходные данные, начальное состояние памяти}}
\put(4,8){\figArrow}
\put(0,4){\framebox(8,2)[c]{Программа}}
\put(4,4){\figArrow}
\put(0,0){\figBox{Результаты, заключительное состояние памяти}}
\end{picture}
\end{center}

Описать семантику программы~-- значит описать свойства отображения исходных данных на результаты.

Задать спецификацию программы~-- значит описать желаемое соотношение между исходными данными и результатами.

Описать семантику управляющей конструкции~-- значит показать, как строится семантика составной программы из семантики программ, охваченных ею.
\end{slide}

\begin{slide}
Метод Ч.\,Э.\,Р.\,Хоара (метод хоаровских троек)
\begin{itemize}
\item Предусловие~-- налагаемое на начальное состояние памяти.
\item Постусловие~-- налагаемое на заключительное состояние.
\item Спецификация~-- предусловие и постусловие вместе.
\item Пред- и постусловие выражены предикатами, в которые входят имена переменных программы.
\end{itemize}
\end{slide}

\begin{slide}
Корректность программы относительно спецификации:
\begin{itemize}
\item Полная: если начальное состояние памяти удовлетворяет предусловию, то программа завершается, причём её заключительное состояние удовлетворяет постусловию.
    \[
        \tripleT{P}{S}{Q} .
    \]
\item Частичная: если начальное состояние памяти удовлетворяет предусловию, и если программа завершается, то её заключительное состояние удовлетворяет постусловию.
    \[
        \tripleP{P}{S}{Q} .
    \]
\item Если исходные данные нарушают предусловие, программа имеет право делать что угодно, никакое её поведение не подтвердит и не опровергнет её корректность.
\end{itemize}
\end{slide}

\begin{slide}
\begin{itemize}
\item Частичная корректность~-- программа имеет право не дать никакого результата, лишь бы не дала неправильный.
\item Ни один запуск программы не даст свидетельства её некорректности (презумпция невиновности).
\item Программа, зависающая на любых исходных данных, корректна (в частичном смысле) относительно любой спецификации.
\item Всегда зависающая программа (в модели частичной корректности)~-- это универсальный решатель любых задач!
\item Если такая программа завершится, она выполнит любое желание.
\item Но она не завершится никогда, поэтому её нельзя будет поймать на невыполнении желания.
\item О ящике, который невозможно открыть, можно смело утверждать, что в нём находится чудо.
\end{itemize}
\end{slide}

\begin{slide}
Примеры спецификаций
\begin{itemize}
\item Нахождение максимума $c$ из значений двух переменных $a$, $b$:
    \[
      \tripleT
        {a = \alpha \land b = \beta}
        {S}
        { c \geqslant \alpha \land c \geqslant \beta \land (c = \alpha \lor c = \beta) } .
    \]
\item Обмен значениями переменных $a$ и $b$
    \[
      \tripleT
        {a = \alpha \land b = \beta}
        {S}
        {a = \beta \land b = \alpha} .
    \]
\item Нахождение наибольшего общего делителя $c$ значений переменных $a$, $b$:
    \[
      \tripleT
        {a = \alpha \land b = \beta}
        {S}
        {P(c) \land \forall \gamma: P(\gamma) \implies \gamma \leqslant c},
    \]
  где через $P(\xi)$ обозначен предикат "<$\xi$ делит $\alpha$ и $\beta$">:
    \[
        P(\xi) = (\exists \delta, \varepsilon: \alpha = \delta\cdot \xi \land \beta = \varepsilon\cdot \xi).
    \]
\end{itemize}
\end{slide}

\begin{slide}
Общие свойства спецификаций и корректности
\begin{itemize}
\item Требование завершимости программы~$S$ на исходных данных из~$P$:
    \[
        \tripleT{P}{S}{\true} .
    \]
\item Требование незавершимости:
    \[
        \tripleP{P}{S}{\false} .
    \]
\item Модель частичной корректности проще, поэтому задачу о полной коррректности разбивают на две: доказательство частичной корректности и отдельно доказательство завершимости:
    \[
        \tripleP{P}{S}{Q}
        \ \land \
        \tripleT{P}{S}{\true}
        \ \implies \ 
        \tripleT{P}{S}{Q} .
    \]
\end{itemize}
\end{slide}

\begin{slide}
\begin{itemize}
\item Тавтологии~-- тождественно истинные спецификации:
        \[
          \tripleP{P}{S}{\true} ,
          \quad
          \tripleP{\false}{S}{Q} .
        \]
\item Законы консеквенции
        \[
                \frac
                {
                        P \implies R, \  \tripleP{R}{S}{Q}
                }
                {
                        \tripleP{P}{S}{Q}
                } ,
                \qquad
                \frac
                {
                        \tripleP{P}{S}{R}, \  R \implies Q
                }
                {
                        \tripleP{P}{S}{Q}
                }
        \]
        усиление пред- и ослабление постусловия.
\item Законы дистрибутивности
      \[
          \frac
          {
              \tripleP{P_1}{S}{Q}, \  \tripleP{P_2}{S}{Q}
          }
          {
              \tripleP{P_1 \lor P_2}{S}{Q}
          },
          \qquad
          \frac
          {
              \tripleP{P}{S}{Q_1}, \  \tripleP{P}{S}{Q_2}
          }
          {
              \tripleP{P}{S}{Q_1 \land Q_2}
          }
      \]
      работают в обе стороны~-- в силу законов консеквенции
\end{itemize}
\end{slide}

\begin{slide}
Две самые важные программы
\begin{itemize}
\item Пустой оператор
        \[
                \tripleP{P}{\nop}{P} .
        \]
\item Зависание
        \[
                \tripleP{P}{\hang}{\false} .
        \]
\end{itemize}
для любого $P$.

Эквивалентность программ по поведению: $S_1 = S_2$, если для любых~$P$, $Q$
\[
        \tripleP{P}{S_1}{Q}
        \ \Leftrightarrow\
        \tripleP{P}{S_2}{Q}
\]

\end{slide}

\begin{slide}
\end{slide}

\begin{slide}
\begin{center}
\begin{LARGE}
Теория, мой друг, суха,\\Но зеленеет жизни древо
\end{LARGE}
\end{center}

\begin{flushright}
\emph{Часть силы той, что без числа\\Творит добро, всему желая зла}
\end{flushright}
\end{slide}

\begin{slide}
        Последовательная композиция
        \begin{center}
                \begin{picture}(18,2)
                        \put(0,0){\makebox(2,2)[c]{\shortstack[c]{$x_0$}}}
                        \put(2,1){\vector(1,0){2}}
                        \put(4,0){\framebox(2,2)[c]{$S_1$}}
                        \put(6,1){\vector(1,0){2}}
                        \put(8,0){\makebox(2,2)[c]{\shortstack[c]{$x_1$}}}
                        \put(10,1){\vector(1,0){2}}
                        \put(12,0){\framebox(2,2)[c]{$S_2$}}
                        \put(14,1){\vector(1,0){2}}
                        \put(16,0){\makebox(2,2)[c]{\shortstack[c]{$x_2$}}}
                \end{picture}
        \end{center}

                Результат первой программы~-- вход второй. Условие, наложенное на промежуточное состояние,
                есть постусловие для~$S_1$ и предусловие для~$S_2$:
                \[
                        \frac
                        {
                                \tripleP{P}{S_1}{Q}
                                \quad
                                \tripleP{Q}{S_2}{R}
                        }
                        {
                                \left\{P\right\}
                                S_1 ; S_2
                                \left\{R\right\}
                        }
                \]

        Теорема об ассоциативности последовательной композиции
        \[
                (S_1;S_2);S_3
                =
                S_1;(S_2;S_3)
        \]
        Аналог ассоциативности сложения:
        \[
                (a + b) + c = a + (b + c).
        \]
\end{slide}

\begin{slide}
        Доказательство ($\Rightarrow$). Пусть $\tripleP{P}{(S_1;S_2);S_3}{Q}$. Тогда существует такое~$T$, что
        \[
                \tripleP{P}{S_1;S_2}{T},\ (1)
                \qquad
                \tripleP{T}{S_3}{Q}.\ (2)
        \]
        Из (1) следует существование такого~$U$, что
        \[
                \tripleP{P}{S_1}{U},\ (3)
                \qquad
                \tripleP{U}{S_2}{T},\ (4)
        \]
        Из (4) и (2) следует
        \[
                \tripleP{U}{S_2;S_3}{Q}. \ (5)
        \]
        Теперь из (3) и (5) следует
        \[
                \tripleP{P}{S_1; (S_2; S_3)}{Q} ,
        \]
        Quod erat demonstrandum.

        Доказательство ($\Leftarrow$) аналогично.
\end{slide}

\begin{slide}
        Особые свойства операторов относительно последовательной композиции
        \begin{itemize}
                \item Пустой оператор, поскольку $\tripleP{R}{\nop}{R}$:
                        \[
                                \nop ; S = S ; \nop = S .
                        \]

                \item Арифметический аналог:
                \[
                        1\cdot x = x\cdot 1 = x
                \]

                \item Зависание, поскольку $\tripleP{R}{\hang}{\false}$:
                        \[
                                S ; \hang = \hang .
                        \]

                \item Арифметический аналог:
                \[
                        0\cdot x = x\cdot 0 = 0
                \]

                \item Не выполняется свойство левого нуля, т.к. $\tripleP{\false}{S}{Q}$:
                        \[
                                \hang ; S \neq \hang .
                        \]
        \end{itemize}
\end{slide}

\begin{slide}
        Ветвление
        \begin{center}
                \begin{picture}(24,9)(-12,-9)
                        \put(-2,0){\makebox(4,1)[c]{\shortstack[c]{$\{P\}$}}}
                        \put(0,0){\vector(0,-1){1}}
                        \put(-4,-2){\line(4,1){4}}
                        \put(-4,-2){\line(4,-1){4}}
                        \put(4,-2){\line(-4,-1){4}}
                        \put(4,-2){\line(-4,1){4}}
                        \put(-4,-4){\makebox(8,4)[c]{\shortstack[c]{$b$}}}
                        \put(-5,-0.5){\makebox(0,0)[rt]{{$\{P \land b\}$}}}
                        \put(5,-0.5){\makebox(0,0)[lt]{{$\{P \land \neg b\}$}}}
                        \put(-4,-2){\line(-1,0){4}}
                        \put(-8,-2){\vector(0,-1){2}}
                        \put(-12,-6){\framebox(8,2)[c]{\shortstack[c]{$S_1$}}}
                        \put(-8,-6){\line(0,-1){2}}
                        \put(-8,-8){\line(1,0){8}}
                        \put(4,-2){\line(1,0){4}}
                        \put(-2,-8.9){\makebox(4,4)[c]{\shortstack[c]{$\{Q\}$}}}
                        \put(8,-2){\vector(0,-1){2}}
                        \put(4,-6){\framebox(8,2)[c]{\shortstack[c]{$S_2$}}}
                        \put(8,-6){\line(0,-1){2}}
                        \put(8,-8){\line(-1,0){8}}
                        \put(0,-8){\vector(0,-1){1}}
                \end{picture}
        \end{center}
        Выполняется программа от начала к концу, а анализируется~-- с конца к началу!
        \[
                \frac
                {
                        \tripleP{P \land b}{S_1}{Q}
                        \quad
                        \tripleP{P \land \neg b}{S_2}{Q}
                }
                {
                        \tripleP{P}{\ifelse{b}{S_1}{S_2}} {Q}
                }
        \]
\end{slide}

\begin{slide}
        Теоремы об эквивалентных преобразованиях

Идемпотентность:
        \[
                S = \ifelse{b}{S}{S} .
        \]

Сокращение:
        \[
                S = \ifelse{\true}{S}{T} .
        \]

Обращение условия:
        \[
                \ifelse{b}{S_1}{S_2} = \ifelse{\neg b}{S_2}{S_1} .
        \]

Дистрибутивность последовательной относительно условной:
        \[
                S_1; \ifelse{b}{S_2}{S_3} = \ifelse{b}{S_1; S_2}{S_1 ;S_3} .
        \]

Перестановка условий:
        \begin{multline*}
                \ifelse{b}{(\ifelse{c}{S_1}{S_2})}{S_3} = \\
                \ifelse{c}{(\ifelse{b}{S_1}{S_3})}{(\ifelse{b}{S_2}{S_3})} .
        \end{multline*}
\end{slide}

\begin{slide}
        Циклическая композиция

        Инвариант цикла~-- предикат~$I$, истинность которого сохраняется телом цикла.

        Если истинность инварианта обеспечена перед входом в цикл, то она
        гарантированно сохраняется после каждой итераци, а значит и после завершения цикла.

        Условие повторения~$b$ необходимо ложно после завершения цикла, ведь в противном случае цикл
        бы не мог завершиться.

        \[
                \frac
                        {\tripleP{b\land I}{S}{I}}
                        {\tripleP{I}{\while{b}{S}}{\neg b\land I}}
        \]

        Пусть $t\geqslant 0$~-- натуральнозначная функция от состояния
        \[
                \frac
                        {\tripleT{I \land b \land t=\tau}{S}{I \land t < \tau}}
                        {\tripleT{I}{\while{b}{S}}{\neg b\land I}}
        \]
\end{slide}

\begin{slide}
        Замечательные свойства циклов:

        \begin{itemize}
        \item Пустой цикл
        \[
                \while{\false}{S} = \nop
        \]
        \item Вечный цикл
        \[
                \while{\true}{S} = \hang
        \]
        \item Поглощение условия внутри
        \[
                \while{b}{(\ifthen{b}{S})} = \while{b}{S}
        \]
        \item Поглощение условия снаружи
        \[
                \ifthen{b}{(\while{b}{S})} = \while{b}{S}
        \]
        \item Неподвижная точка
        \[
                \ifthen{b}{S} ; \while{b}{S} = \while{b}{S}
        \]
        \end{itemize}
\end{slide}

\begin{slide}
\end{slide}

\begin{slide}
\end{slide}

\begin{slide}
\end{slide}

\begin{slide}
\begin{Large}
Теория — это когда все известно, но ничего не работает.

Практика — это когда все работает, но никто не знает почему.

Мы же объединяем теорию и практику: ничего не работает, и никто не знает почему!
\end{Large}

\begin{flushright}
\emph{Альберт Эйнштейн}
\end{flushright}
\end{slide}

\begin{slide}
        Важные вспомогательные сведения
        \begin{itemize}
                \item Предикат~$P(x)$ определяет множество~$M=\{x\mid P(x)\}$ и наоборот~-- множество~$M$
                        определяет предикат~$P(x) = x\in M$.
                \item Импликация есть логическая операция (т.е. $P\implies Q$ есть, в свою очередь,
                        придикат, который может быть истинным или ложным), а также моделирует отношение логического
                        следования между предикатами (из~$P$ следует~$Q$ т.т.т., когда предикат~$P\implies Q$~-- истинный).
                \item Отношение логического следования может рассматриваться как отношение частичного порядка
                        над предикатами: предикат~$P$ "<меньше">, чем~$Q$, если и только если~$P\implied Q$.
                \item \emph{Частичный} порядок означает, что не все предикаты сравнимы между собой: например,
                        если~$P=(x>10)$, а $Q=(x<30)$, то $P\not\implied Q$ и $Q\not\implied P$.
        \end{itemize}
\end{slide}

\begin{slide}
        Важные вспомогательные сведения
        \begin{itemize}
                \item "<Меньше"> для предикатов означает "<слабее">.
                \item Наименьший из всех предикатов~-- тождественно истинный предикат~$\true$, наибольший~--
                        тождественно ложный~$\false$.
                \item Из свойства дизъюнкции (если $R=P\lor Q$, то $R\implied P$ и $R\implied Q$) следует, что
                        дизъюнкция есть \emph{точная нижняя грань} двух предикатов ($R$~есть наибольший из всех
                        предикатов, меньших, чем оба~$P$ и~$Q$), т.е. $P\lor Q = \infinum\{P, Q\}$.
                \item Дуальным образом, конъюнкция есть \emph{точная верхняя грань} двух предикатов,
                        $P\land Q = \supremum\{P, Q\}$.
        \end{itemize}
\end{slide}

\begin{slide}
        Неадекватности хоаровской модели частичной корректности

        Всегда зависающая программа выглядит универсальным исполнителем желаний: для любого~$Q$
        \[
                \tripleP{\true}{\hang}{Q} .
        \]

        Всегда зависающая программа является правым нулём последовательной композиции
                        \[
                                S ; \hang = \hang ,
                        \]
        но не является левым нулём:
                        \[
                                \hang ; S = S .
                        \]

        Общий вывод: хоаровская модель частичной корректности~-- слишком грубый инструмент для исследования
        некоторых существенных свойств реальных программ.
        
        Результаты, выводимые с её помощью, несут не только
        адекватное знание об исследуемой программе, но и сильный отпечаток самого этого инструмента.
\end{slide}

\begin{slide}
        На пути к лучшей модели

        Программа может удовлетворять многим спецификациям:
        \begin{eqnarray*}
                &\tripleT{x=0}{x\assign x\times 2}{x=0}, \\
                &\tripleT{x>10}{x\assign x\times 2}{x>20}, \\
                &\tripleT{\true}{x\assign x\times 2}{x\ \mathrm{mod}\ 2 = 0} .
        \end{eqnarray*}

        Зафиксируем постусловие, так как оно в реальном процессе определено заказчиком.
        Программа может гарантировать его достижение при многих разных предусловиях:
        \begin{eqnarray*}
                &\tripleT{x>100 \land x < 200}{x\assign x\times 2}{x>20}, \\
                &\tripleT{x>80 \land x\,\mathrm{mod}\,4=0}{x\assign x\times 2}{x>20}, \\
                &\tripleT{x=30}{x\assign x\times 2}{x>20}.
        \end{eqnarray*}
\end{slide}

\begin{slide}
        Пусть~$M$~-- множество всех таких предусловий, при которых программа~$S$ гарантирует достижение
        постусловия~$Q$:
        \[
                M = \{ P \mid \tripleT{P}{S}{Q} \} .
        \]

        Существует и единственно такое предусловие~$R\in M$, что
        \[
                P \implied R\quad\text{для всех}\ P\in M .
        \]

        Это дизъюнкция всех предусловий~$P\in M$, а также наибольший элемент множества~$M$:
        \[
                R = \bigvee_{S\in M} S = \max M.
        \]
        
        Называем~$R$ \emph{слабейшим предусловием программы~$S$ относительно постусловия~$Q$}
        и обозначаем
        \[
                R = \wpof{S}{Q} .
        \]
\end{slide}

\begin{slide}
        Теперь семантика программы~$S$ моделируется функционалом (преобразователем предикатов)~$\wpof{S}{\cdot}$,
        который всякому желаемому постусловию~$Q$ ставит в соответствие самое слабое предусловие~$P$, которое
        гарантирует, что программа~$S$ завершится и даст правильный (удовлетворяющий~$Q$ результат).

        Примеры:
        \begin{eqnarray*}
                &\wpof{x\assign x+1}{x>10} = (x > 9) ,\\
                &\wpof{x\assign x+1}{x\, \mathrm{mod}\, 2 = 0} = (x\, \mathrm{mod}\, 2 = 1) ,\\
                &\wpof{x\assign x\times 2}{x = 7} = \false .
        \end{eqnarray*}
\end{slide}

\begin{slide}
        Общие свойства функционала~$\wpsign$:

        \begin{itemize}
                \item Закон исключённого чуда:
                        \[
                                \wpof{S}{\false} = \false .
                        \]
                \item Монотонность:
                        \[
                                (Q_1\implies Q_2)
                                \implies
                                (\wpof{S}{Q_1} \implies \wpof{S}{Q_2}) .
                        \]
                \item Дистрибутивность конъюнкции:
                        \[
                                \wpof{S}{Q_1} \land \wpof{S}{Q_2} = \wpof{S}{Q_1 \land Q_2} .
                        \]
        \end{itemize}
\end{slide}

\begin{slide}
        Дистрибутивность дизъюнкции в общем случае:
        \[
                \wpof{S}{Q_1} \lor \wpof{S}{Q_2} \implies \wpof{S}{Q_1 \lor Q_2} .
        \]
        Контрпример для~$\implied$: пусть
        \begin{eqnarray*}
                &S = (x \assign random(2)),\\
                &Q_1 = (x = 0),\\
                &Q_2 = (x = 1),
        \end{eqnarray*}
        тогда
        \begin{eqnarray*}
                &Q_1 \lor Q_2 = \true.\\
                &\wpof{S}{Q_1 \lor Q_2} = \true .
        \end{eqnarray*}
        Однако
        \[
                \wpof{S}{Q_1} = \wpof{S}{Q_2} = \false .
        \]

        Дистрибутивность дизъюнкции в обе стороны работает для детерминированных программ и только для них!
\end{slide}

\begin{slide}
        Важнейшие частные случаи:

        \begin{itemize}
                \item Пустая программа:
                        \[
                                \wpof{\nop}{Q} = Q .
                        \]
                \item Всегда зависающая программа: для любого~$Q$
                        \[
                                \wpof{\hang}{Q} = \false .
                        \]
                \item Условие завершимости программы:
                        \[
                                \wpof{S}{\true} .
                        \]
        \end{itemize}
\end{slide}

\begin{slide}
        Последовательная композиция

        \begin{center}
                \begin{picture}(18,2)
                        \put(0,0){\makebox(2,2)[c]{\shortstack[c]{$x_0$}}}
                        \put(2,1){\vector(1,0){2}}
                        \put(4,0){\framebox(2,2)[c]{$S_1$}}
                        \put(6,1){\vector(1,0){2}}
                        \put(8,0){\makebox(2,2)[c]{\shortstack[c]{$x_1$}}}
                        \put(10,1){\vector(1,0){2}}
                        \put(12,0){\framebox(2,2)[c]{$S_2$}}
                        \put(14,1){\vector(1,0){2}}
                        \put(16,0){\makebox(2,2)[c]{\shortstack[c]{$x_2$}}}
                \end{picture}
        \end{center}

        Результат первой программы~-- вход второй. Условие, наложенное на промежуточное состояние,
        есть постусловие для~$S_1$ и предусловие для~$S_2$:
        \[
                \wpof{S_1;S_2}{Q} = \wpof{S_1}{\wpof{S_2}{Q}} .
        \]
\end{slide}

\begin{slide}
        Ветвление
        \begin{center}
                \begin{picture}(24,9)(-12,-9)
                        \put(-2,0){\makebox(4,1)[c]{\shortstack[c]{$\{P\}$}}}
                        \put(0,0){\vector(0,-1){1}}
                        \put(-4,-2){\line(4,1){4}}
                        \put(-4,-2){\line(4,-1){4}}
                        \put(4,-2){\line(-4,-1){4}}
                        \put(4,-2){\line(-4,1){4}}
                        \put(-4,-4){\makebox(8,4)[c]{\shortstack[c]{$b$}}}
                        \put(-5,-0.5){\makebox(0,0)[rt]{{$\{P \land b\}$}}}
                        \put(5,-0.5){\makebox(0,0)[lt]{{$\{P \land \neg b\}$}}}
                        \put(-4,-2){\line(-1,0){4}}
                        \put(-8,-2){\vector(0,-1){2}}
                        \put(-12,-6){\framebox(8,2)[c]{\shortstack[c]{$S_1$}}}
                        \put(-8,-6){\line(0,-1){2}}
                        \put(-8,-8){\line(1,0){8}}
                        \put(4,-2){\line(1,0){4}}
                        \put(-2,-8.9){\makebox(4,4)[c]{\shortstack[c]{$\{Q\}$}}}
                        \put(8,-2){\vector(0,-1){2}}
                        \put(4,-6){\framebox(8,2)[c]{\shortstack[c]{$S_2$}}}
                        \put(8,-6){\line(0,-1){2}}
                        \put(8,-8){\line(-1,0){8}}
                        \put(0,-8){\vector(0,-1){1}}
                \end{picture}
        \end{center}
        \begin{eqnarray*}
                &IF = (\ifelse{b}{S_1}{S_2}) , \\
                &\wpof{IF}{Q} =
                (b \implies \wpof{S_1}{Q}) \land
                (\neg b \implies \wpof{S_2}{Q}) .
        \end{eqnarray*}
\end{slide}

\begin{slide}
        Циклическая композиция $DO = \while{b}{S}$

        Любое разумное постусловие обязательно включает в себя~$\neg b$:
        \[
                \wpof{DO}{b} = \false ,
        \]
        Поэтому его можно представить в виде
        \[
                Q = I\land \neg b .
        \]

        Метод последовательных приближений. В предельном случае
        цикл может завершиться, не сделав ни одной итерации~--
        если условие продолжения~$b$ изначально ложно. Условие этого:
        \[
                P_0 = \wpof{\nop}{Q} = Q = I\land \neg b .
        \]
\end{slide}

\begin{slide}
        Цикл может завершиться за одну итерацию или менее:
        \[
                P_1 = P_0 \lor \wpof{S}{Q} = P_0 \lor \wpof{S}{P_0} .
        \]

        Пусть $P_k$~-- условие того, что цикл завершается за не более, чем~$k$ итараций.
        Тогда
        \[
                P_{k+1} = P_k \lor \wpof{S}{P_k} .
        \]

        Теперь условие того, что цикл завершится за какое-либо число итераций, есть
        \[
                \wpof{DO}{Q} = \bigvee_{n=0}^{\infty} P_k .
        \]
\end{slide}

\begin{slide}
        Метод неподвижной точки

        Неподвижной точкой функции~$f$ называется такой объект~$x$, что
        \[
                x = f(x) .
        \]
        Если область определения функции~$f$ представляет собой полную решётку и~$\bot$ есть её
        наименьший элемент, то наименьшая неподвижная точка~$f$ строится методом последовательных
        приближений:
        \begin{eqnarray*}
                &x_0 = \bot,\\
                &x_{k+1} = f(x_k),\\
                &x^* = \supremum \{ x_k \mid k=0,\ldots,\infty\} .
        \end{eqnarray*}

        Из определения цикла (см. также лекцию~2) следует, что
        \[
                DO = \ifthen{b}{S; DO} ,
        \]
        следовательно, цикл есть неподвижная точка функционала
        \[
                IF(X) = \ifthen{b}{X; DO} .
        \]
\end{slide}

\begin{slide}
        Непрерывность

        Функция~$f$, определённая на полной решётке, называется непрерывной, если она сохраняет пределы.
        Пусть
        \[
                x_0\prec x_1\prec\ldots\prec x_k\prec x_{k+1}\prec\ldots
        \]
        Тогда непрерывность означает, что
        \[
                f\left(\sup{x_k}\right) = \sup f\left(x_k\right) .
        \]

        Пример функции, не являющейся непрерывной:
        \begin{eqnarray*}
                &f(1) = 1 ,\\
                &f(x) = 0\ \text{при}\ x<1.
        \end{eqnarray*}
        Пусть $x_k = \frac{k}{k+1}$. Очевидно, что~$x_k < 1$, поэтому $f(x_k) = 0$, и
        \[
                \sup f(x_k) = 0 .
        \]
        Однако $\sup x_k = 1$, поэтому
        \[
                f(\sup x_k) = 1 .
        \]
\end{slide}

\begin{slide}
        Метод неподвижной точки работает только для непрерывных\\функций!

        К счастью, функционалы~$\wpof{S}{\cdot}$ для всех базовых операторов и всех программ,
        которые возможно построить из них с помощью композиций, непрерывны.

        Условие непрерывности означает ограничение на максимально возможную недетерминированность
        программ. Невозможна программа~$\chaos$, завершающаяся в абсолютно непредсказуемом состоянии.

        В противном случае, если $Q_k\ne\true$ и $\sup Q_k = \true$, то
        \[
                \wpof{\chaos}{\sup Q_k} = \true,
        \]
        но
        \[
                \sup \wpof{\chaos}{Q_k} = \false.
        \]
\end{slide}

\begin{slide}
    \begin{center}
        \begin{LARGE}
            TODO: Сюда вставить какой-то смешной и умный афоризм о теории и практике
        \end{LARGE}
    \end{center}
\end{slide}

\begin{slide}
Литература
\begin{itemize}
\item Hoare, C.\,A.\,R. An axiomatic basis for computer programming.\\Communications of the ACM 12 (10): 576–580.
\item Floyd, R.\,W. Assigning meanings to programs. Proceedings of the American Mathematical Society Symposia on Applied Mathematics. Vol. 19, pp. 19–31. 1967.
\item Hoare, C.\,A.\,R. and He Jifeng, Unifying Theories of Programming, Prentice Hall International Series in Computer Science, 1998.\\http://unifyingtheories.org
\end{itemize}
\end{slide}

\begin{slide}
\begin{itemize}
\item Дейкстра Э. Дисциплина программирования. — М.: Мир, 1978. — 280 с.
\item Грис Д. Наука программирования. — М.: Мир, 1984. — 289 с.
\item Алагич С., Арбиб М. Проектирование корректных структурированных программ. — М.: Радио и связь, 1984. — 264 с.
\item Андерсон Р. Доказательство правильности программ. — М.: Мир, 1982 — 287 с.
\item Калинин А.Г., Мацкевич И.В. Универсальные языки программирования. Семантический подход. — М.: Радио и связь, 1991. — 400 с.
\end{itemize}
\end{slide}

\begin{slide}
\begin{itemize}
\item Абрамов С.А  Элементы анализа программ. Частичные функции на множестве состояний. — М.: Наука, 1986. — 128 с.
\item Замулин А.В. Формальная модель Java-программы, основанная на машинах абстрактных состояний // Программирование. — 2003. — № 3. — С. 15–28.
\item Замулин А.В. Формальная семантика выражений и операторов языка Java // Программирование. — 2003. — № 5. — С. 31–45.
\item Замулин А.В. Алгебраическая семантика императивного языка программирования // Программирование. — 2003. — № 6. — С. 51–64.
\item Egon Börger and Robert Stärk, Abstract State Machines: A Method for High-Level System Design and Analysis. Springer-Verlag, 2003.
\end{itemize}
\end{slide}

\end{document}
